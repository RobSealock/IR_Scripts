<#
.QUICK NOTES
LocalLogons.ps1
RobSealock @ 2026-02-14
version 0.5

.REQUIRES -RunAsAdministrator
.OPT-IN SWITCHES
  .ACCOUNTS
    Suppress Noise Accounts: To hide SYSTEM, LOCAL SERVICE, UMFD
    -IncludeNoiseAccounts:$false
    -Include Machine Accounts
    -IncludeComputerAccounts
  .TIME WINDOWS (48hrs default)
    -Window Max
    -Window 1h
    -Window 24h
  .OUTPUTS
    -OutputCsv "C:\Temp\Sessions.csv"
    -OutputHtml "C:\Temp\LogonReview.html"
    -DebugLogPath "C:\Temp\LocalLogons_Debug.txt"
    .COMBINED ALLOWED
      -OutputCsv "C:\Temp\Sessions.csv" -OutputHtml "C:\Temp\LogonReview.html"

.SYNOPSIS
  Review Windows logon/logoff activity (user + service accounts) with reboot annotations,
  post-reboot summaries, session correlation, risk scoring, group membership, gap analysis,
  and PS 5.1-safe HTML/CSV reporting.

.DESCRIPTION
  - Logons: 4624 (Security)
  - Logoffs: 4634, 4647 (Security)
  - Reboot/Shutdown markers: 6005, 6006, 6008, 41, 1074, 6009 (System)

  Output:
  - Max timeline discovery (oldest event available)
  - Timeline objects combining logon/logoff + reboot notes
  - Correlated sessions (logon â†’ logoff, duration, risk, groups, off-hours, gaps)
  - Post-reboot summaries
  - Optional CSV/HTML exports (color-coded risk) without AD/ADSI dependencies

.PARAMETER Window
  One of: Max, 48h, 24h, 1h

.PARAMETER Hours
  Optional custom lookback in hours (overrides Window except Max)

.PARAMETER IncludeComputerAccounts
  Include accounts ending with '$' (machine accounts). Default: $false.

.PARAMETER IncludeNoiseAccounts
  Include built-in noise (e.g., LOCAL SERVICE, NETWORK SERVICE, SYSTEM, UMFD-*, DWM-*). Default: $true.

.PARAMETER OutputCsv
  Optional path to write CSV with correlated sessions.

.PARAMETER OutputHtml
  Optional path to write HTML report (timeline + sessions).

.PARAMETER DebugLogPath
  TEMPORARY: Optional path to write debug/test log information during development.
  This should be removed once testing is complete.

#>

[CmdletBinding()]
param(
  [ValidateSet("Max","48h","24h","1h")]
  [string]$Window = "48h",

  [int]$Hours,

  [switch]$IncludeComputerAccounts,

  [switch]$IncludeNoiseAccounts,

  [string]$OutputCsv,

  [string]$OutputHtml,

  [string]$DebugLogPath
)

Set-StrictMode -Version Latest

# -----------------------------
# TEMP: Debug logging helper
# -----------------------------
function Write-DebugLog {
  param(
    [Parameter(Mandatory)][string]$Message
  )
  if (-not $DebugLogPath) { return }
  try {
    $timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss.fff")
    "$timestamp`t$Message" | Out-File -FilePath $DebugLogPath -Encoding UTF8 -Append
  } catch {
    # Swallow logging errors; this is only for test phase
  }
}

Write-DebugLog -Message "Script start. Window=$Window; Hours=$Hours; IncludeComputerAccounts=$IncludeComputerAccounts; IncludeNoiseAccounts=$IncludeNoiseAccounts"

# -----------------------------
# Helpers
# -----------------------------

function Get-EventOldestTime {
  param(
    [Parameter(Mandatory)] [string]$LogName,
    [Parameter(Mandatory)] [int[]]$Ids
  )
  try {
    $ev = Get-WinEvent -FilterHashtable @{ LogName=$LogName; Id=$Ids } -MaxEvents 1 -ErrorAction Stop -Oldest
    return $ev.TimeCreated
  } catch {
    return $null
  }
}

function Get-EventNewestTime {
  param(
    [Parameter(Mandatory)] [string]$LogName,
    [Parameter(Mandatory)] [int[]]$Ids
  )
  try {
    $ev = Get-WinEvent -FilterHashtable @{ LogName=$LogName; Id=$Ids } -MaxEvents 1 -ErrorAction Stop
    return $ev.TimeCreated
  } catch {
    return $null
  }
}

function Get-StartTime {
  param([string]$Window,[int]$Hours)

  if ($Window -eq "Max") { return $null }
  if ($PSBoundParameters.ContainsKey('Hours') -and $Hours -gt 0) {
    return (Get-Date).AddHours(-1 * $Hours)
  }

  switch ($Window) {
    "48h" { return (Get-Date).AddHours(-48) }
    "24h" { return (Get-Date).AddHours(-24) }
    "1h"  { return (Get-Date).AddHours(-1) }
    default { return (Get-Date).AddHours(-48) }
  }
}

function ConvertFrom-WinEventXmlData {
  param([Parameter(Mandatory)] $WinEvent)

  $xml = [xml]$WinEvent.ToXml()
  $data = @{}
  foreach ($d in $xml.Event.EventData.Data) {
    if ($d.Name) { $data[$d.Name] = [string]$d.InnerText }
  }
  return $data
}

function Get-LogonTypeName {
  param([Parameter(Mandatory)][int]$LogonType)

  switch ($LogonType) {
    2  { return "Interactive" }
    3  { return "Network" }
    4  { return "Batch" }
    5  { return "Service" }
    7  { return "Unlock" }
    8  { return "NetworkCleartext" }
    9  { return "NewCredentials" }
    10 { return "RemoteInteractive" }
    11 { return "CachedInteractive" }
    12 { return "CachedRemoteInteractive" }
    13 { return "CachedUnlock" }
    default { return "Other" }
  }
}

# BigInteger support (PS 5.1-safe)
try {
  Add-Type -AssemblyName System.Numerics -ErrorAction SilentlyContinue
} catch {}

function Format-LogonId {
  param([string]$LogonId)

  if (-not $LogonId) { return $null }
  $trim = $LogonId.Trim()

  # Hex with 0x prefix
  if ($trim -match '^0x[0-9A-Fa-f]+$') {
    $hex = $trim.Substring(2)
    try {
      if ([type]::GetType("System.Numerics.BigInteger")) {
        $val = [System.Numerics.BigInteger]::Parse($hex, [System.Globalization.NumberStyles]::HexNumber)
        return ('{0:X}' -f $val)
      } else {
        $val = [int64]::Parse($hex, [System.Globalization.NumberStyles]::HexNumber)
        return ('{0:X}' -f $val)
      }
    } catch {
      return $trim.ToUpperInvariant()
    }
  }
  # Hex without prefix but with letters
  elseif ($trim -match '^[0-9A-Fa-f]+$' -and $trim -match '[A-Fa-f]') {
    try {
      if ([type]::GetType("System.Numerics.BigInteger")) {
        $val = [System.Numerics.BigInteger]::Parse($trim, [System.Globalization.NumberStyles]::HexNumber)
        return ('{0:X}' -f $val)
      } else {
        $val = [int64]::Parse($trim, [System.Globalization.NumberStyles]::HexNumber)
        return ('{0:X}' -f $val)
      }
    } catch {
      return $trim.ToUpperInvariant()
    }
  }
  # Decimal
  elseif ($trim -match '^\d+$') {
    try {
      if ([type]::GetType("System.Numerics.BigInteger")) {
        $val = [System.Numerics.BigInteger]::Parse($trim)
        return ('{0:X}' -f $val)
      } else {
        $val = [int64]::Parse($trim)
        return ('{0:X}' -f $val)
      }
    } catch {
      return $trim.ToUpperInvariant()
    }
  }

  return $trim.ToUpperInvariant()
}

function Test-IncludeAccount {
  param(
    [Parameter(Mandatory)][string]$User,
    [Parameter(Mandatory)][string]$Domain,
    [switch]$IncludeComputerAccounts,
    [switch]$IncludeNoiseAccounts
  )

  if (-not $IncludeComputerAccounts -and $User.EndsWith('$')) { return $false }

  if (-not $IncludeNoiseAccounts) {
    $noiseUsers = @(
      "SYSTEM","LOCAL SERVICE","NETWORK SERVICE","ANONYMOUS LOGON"
    )

    if ($noiseUsers -contains $User) { return $false }

    # UMFD-* and DWM-* patterns
    if ($User -match '^UMFD-\d+$') { return $false }
    if ($User -match '^DWM-\d+$')  { return $false }

    if ($Domain -eq "NT AUTHORITY" -and $noiseUsers -contains $User) { return $false }
    if ($Domain -eq "NT SERVICE") { return $false }
    if ($Domain -eq "IIS APPPOOL") { return $false }
  }

  return $true
}

function Get-RebootMarkers {
  param([datetime]$StartTime)

  $ids = 6005,6006,6008,41,1074,6009
  $filter = @{ LogName="System"; Id=$ids }
  if ($StartTime) { $filter.StartTime = $StartTime }

  $events = Get-WinEvent -FilterHashtable $filter -ErrorAction SilentlyContinue |
    Sort-Object TimeCreated

  Write-DebugLog -Message ("Get-RebootMarkers: collected {0} events" -f ($events.Count))

  $events | ForEach-Object {
    $note = switch ($_.Id) {
      6005 { "EventLog service started (boot/reboot marker)" }
      6006 { "EventLog service stopped (clean shutdown marker)" }
      6008 { "Unexpected shutdown detected" }
      41   { "Kernel-Power: unexpected reboot/power loss" }
      1074 { "Planned shutdown/restart initiated" }
      6009 { "OS version reported at boot" }
      default { "Reboot/Shutdown marker" }
    }

    [pscustomobject]@{
      Time      = $_.TimeCreated
      Kind      = "RebootMarker"
      EventId   = $_.Id
      Account   = $null
      LogonType = $null
      LogonKind = $null
      LogonId   = $null
      IpAddress = $null
      Process   = $null
      Notes     = $note
    }
  }
}

function Get-LogonEvents {
  param(
    [datetime]$StartTime,
    [switch]$IncludeComputerAccounts,
    [switch]$IncludeNoiseAccounts
  )

  $filter = @{ LogName="Security"; Id=4624 }
  if ($StartTime) { $filter.StartTime = $StartTime }

  $events = Get-WinEvent -FilterHashtable $filter -ErrorAction SilentlyContinue
  Write-DebugLog -Message ("Get-LogonEvents: raw 4624 count={0}" -f ($events.Count))

  $events | ForEach-Object {
    $d = ConvertFrom-WinEventXmlData -WinEvent $_

    $user    = $d["TargetUserName"]
    $domain  = $d["TargetDomainName"]
    $ltRaw   = $d["LogonType"]
    $logonId = Format-LogonId -LogonId $d["TargetLogonId"]
    $ip      = $d["IpAddress"]
    $proc    = $d["ProcessName"]

    if (-not $user) { return }

    if (-not (Test-IncludeAccount -User $user -Domain $domain -IncludeComputerAccounts:$IncludeComputerAccounts -IncludeNoiseAccounts:$IncludeNoiseAccounts)) {
      return
    }

    $lt = 0
    [void][int]::TryParse($ltRaw, [ref]$lt)
    $kind = Get-LogonTypeName -LogonType $lt

    [pscustomobject]@{
      Time      = $_.TimeCreated
      Kind      = "Logon"
      EventId   = 4624
      Account   = if ($domain) { "$domain\$user" } else { $user }
      LogonType = $lt
      LogonKind = $kind
      LogonId   = $logonId
      IpAddress = $ip
      Process   = $proc
      Notes     = $null
    }
  }
}

function Get-LogoffEvents {
  param(
    [datetime]$StartTime,
    [switch]$IncludeComputerAccounts,
    [switch]$IncludeNoiseAccounts
  )

  $filter = @{ LogName="Security"; Id=4634,4647 }
  if ($StartTime) { $filter.StartTime = $StartTime }

  $events = Get-WinEvent -FilterHashtable $filter -ErrorAction SilentlyContinue
  Write-DebugLog -Message ("Get-LogoffEvents: raw 4634/4647 count={0}" -f ($events.Count))

  $events | ForEach-Object {
    $d = ConvertFrom-WinEventXmlData -WinEvent $_

    $user    = $d["TargetUserName"]
    $domain  = $d["TargetDomainName"]
    $logonId = $d["LogonId"]
    if (-not $logonId) { $logonId = $d["TargetLogonId"] }
    $logonId = Format-LogonId -LogonId $logonId

    # Some 4647 events have TargetUserName = "-"
    if (-not $user -or $user -eq "-") {
      $user = $null
    }

    if ($user) {
      if (-not (Test-IncludeAccount -User $user -Domain $domain -IncludeComputerAccounts:$IncludeComputerAccounts -IncludeNoiseAccounts:$IncludeNoiseAccounts)) {
        return
      }
    }

    [pscustomobject]@{
      Time      = $_.TimeCreated
      Kind      = "Logoff"
      EventId   = $_.Id
      Account   = if ($user -and $domain) { "$domain\$user" } elseif ($user) { $user } else { $null }
      LogonType = $null
      LogonKind = $null
      LogonId   = $logonId
      IpAddress = $null
      Process   = $null
      Notes     = if ($_.Id -eq 4647) { "User initiated logoff" } else { $null }
    }
  }
}

function Get-LastBootMarkerTime {
  try {
    $os = Get-CimInstance Win32_OperatingSystem -ErrorAction Stop
    if ($os.LastBootUpTime) { return [datetime]$os.LastBootUpTime }
  } catch {}

  try {
    $ev = Get-WinEvent -FilterHashtable @{ LogName="System"; Id=6005 } -MaxEvents 1 -ErrorAction Stop
    return $ev.TimeCreated
  } catch {
    return $null
  }
}

function Get-UniqueByProperties {
  param(
    [Parameter(Mandatory)]$InputObjects,
    [Parameter(Mandatory)][string[]]$Properties
  )

  $seen = New-Object 'System.Collections.Generic.HashSet[string]'
  $out  = New-Object 'System.Collections.Generic.List[object]'

  foreach ($obj in $InputObjects) {
    $parts = foreach ($p in $Properties) { [string]($obj.$p) }
    $key   = ($parts -join '|')

    if (-not $seen.Contains($key)) {
      [void]$seen.Add($key)
      $out.Add($obj)
    }
  }

  $out
}

function Get-CurrentLoggedOnUsers {
  $results = @()

  try {
    $sessions = Get-CimInstance Win32_LogonSession -ErrorAction Stop
    foreach ($s in $sessions) {
      $links = Get-CimAssociatedInstance -InputObject $s -Association Win32_LoggedOnUser -ErrorAction SilentlyContinue
      foreach ($l in $links) {
        $name = $l.Name
        $dom  = $l.Domain
        if ($name) {
          $results += [pscustomobject]@{
            Account   = if ($dom) { "$dom\$name" } else { $name }
            LogonId   = Format-LogonId -LogonId ("{0}" -f $s.LogonId)
            LogonType = $s.LogonType
            StartTime = if ($s.StartTime) { [datetime]$s.StartTime } else { $null }
          }
        }
      }
    }
  } catch {
    try {
      $raw = (quser 2>$null)
      foreach ($line in $raw | Select-Object -Skip 1) {
        $trim = ($line -replace '\s+', ' ').Trim()
        if (-not $trim) { continue }
        $user = ($trim.Split(' '))[0]
        $results += [pscustomobject]@{
          Account   = $user
          LogonId   = $null
          LogonType = $null
          StartTime = $null
        }
      }
    } catch {}
  }

  Write-DebugLog -Message ("Get-CurrentLoggedOnUsers: count={0}" -f ($results.Count))

  Get-UniqueByProperties -InputObjects $results -Properties @('Account','LogonId')
}

# -----------------------------
# Group resolution via WMI/CIM only (optimized)
# -----------------------------

# Cache to avoid repeated WMI calls
$script:AccountGroupCache = @{}

function Get-AccountGroups {
  param(
    [Parameter(Mandatory)][string]$Account
  )

  if ($script:AccountGroupCache.ContainsKey($Account)) {
    return $script:AccountGroupCache[$Account]
  }

  if ($Account -notmatch '^(?<dom>[^\\]+)\\(?<usr>.+)$') {
    $script:AccountGroupCache[$Account] = @()
    return @()
  }

  $dom = $Matches['dom']
  $usr = $Matches['usr']

  $groups = New-Object 'System.Collections.Generic.List[string]'

  try {
    $acct = Get-CimInstance Win32_Account -Filter ("Name='{0}' AND Domain='{1}'" -f $usr.Replace("'","''"), $dom.Replace("'","''")) -ErrorAction SilentlyContinue
    if ($acct) {
      $rels = Get-CimAssociatedInstance -InputObject $acct -Association Win32_GroupUser -ErrorAction SilentlyContinue
      foreach ($rel in $rels) {
        if ($rel -is [Microsoft.Management.Infrastructure.CimInstance] -and $rel.CimClass.CimClassName -eq 'Win32_Group') {
          if ($rel.Name) {
            $groups.Add($rel.Name) | Out-Null
          }
        }
      }
    }
  } catch {
    # ignore
  }

  $result = $groups | Sort-Object -Unique
  $script:AccountGroupCache[$Account] = $result
  Write-DebugLog -Message ("Get-AccountGroups: Account={0}, Groups={1}" -f $Account, ($result -join ","))

  $result
}

function Test-OffHours {
  param([datetime]$Time)

  if (-not $Time) { return $false }
  $hour = $Time.Hour
  return ($hour -lt 6 -or $hour -gt 18)
}

function Get-RiskScore {
  param(
    [string]$LogonKind,
    [string]$IpAddress,
    [string[]]$Groups,
    [datetime]$LogonTime
  )

  $score = 0
  $tags  = New-Object 'System.Collections.Generic.List[string]'

  switch ($LogonKind) {
    "RemoteInteractive" { $score += 50; $tags.Add("RDP") | Out-Null }
    "NetworkCleartext"  { $score += 40; $tags.Add("Cleartext") | Out-Null }
    "NewCredentials"    { $score += 40; $tags.Add("RunAs/PassTheHash") | Out-Null }
    "Network"           { $score += 20; $tags.Add("Network") | Out-Null }
  }

  if ($IpAddress -and $IpAddress -notin @("127.0.0.1","::1")) {
    $score += 10
    $tags.Add("RemoteIP") | Out-Null
  }

  $privGroups = @(
    "Administrators",
    "Domain Admins",
    "Enterprise Admins",
    "Remote Desktop Users",
    "Backup Operators",
    "Power Users"
  )

  $matched = $Groups | Where-Object { $privGroups -contains $_ }
  if ($matched) {
    $score += 50
    $tags.Add("PrivilegedGroup: " + ($matched -join ",")) | Out-Null
  }

  if (Test-OffHours -Time $LogonTime) {
    $score += 15
    $tags.Add("OffHours") | Out-Null
  }

  $isHighRisk = $score -ge 60

  [pscustomobject]@{
    RiskScore  = $score
    RiskTags   = ($tags -join ", ")
    IsHighRisk = $isHighRisk
  }
}

function Join-Sessions {
  param(
    [Parameter(Mandatory)]$Logons,
    [Parameter(Mandatory)]$Logoffs,
    [datetime]$StartTime
  )

  $logonById = @{}
  foreach ($l in $Logons) {
    if (-not $l.LogonId) { continue }
    if (-not $logonById.ContainsKey($l.LogonId)) {
      $logonById[$l.LogonId] = New-Object 'System.Collections.Generic.List[object]'
    }
    $logonById[$l.LogonId].Add($l)
  }

  $sessions = New-Object 'System.Collections.Generic.List[object]'

  foreach ($lo in $Logoffs) {
    if (-not $lo.LogonId) { continue }
    if (-not $logonById.ContainsKey($lo.LogonId)) { continue }

    # Also match on Account when available to reduce mis-correlation
    $candidates = $logonById[$lo.LogonId] | Where-Object {
      $_.Time -le $lo.Time -and (
        -not $lo.Account -or -not $_.Account -or $_.Account -eq $lo.Account
      )
    }
    if (-not $candidates) { continue }

    $logon = $candidates | Sort-Object Time -Descending | Select-Object -First 1

    $duration = $null
    if ($logon.Time -and $lo.Time) {
      $duration = $lo.Time - $logon.Time
    }

    $groups = Get-AccountGroups -Account $logon.Account
    $risk   = Get-RiskScore -LogonKind $logon.LogonKind -IpAddress $logon.IpAddress -Groups $groups -LogonTime $logon.Time

    $sessions.Add([pscustomobject]@{
      Account      = $logon.Account
      Groups       = $groups -join ", "
      LogonId      = $logon.LogonId
      LogonTime    = $logon.Time
      LogoffTime   = $lo.Time
      Duration     = $duration
      LogonKind    = $logon.LogonKind
      LogonType    = $logon.LogonType
      IpAddress    = $logon.IpAddress
      Process      = $logon.Process
      LogoffEvent  = $lo.EventId
      LogoffNotes  = $lo.Notes
      RiskScore    = $risk.RiskScore
      RiskTags     = $risk.RiskTags
      IsHighRisk   = $risk.IsHighRisk
      WindowStart  = $StartTime
      IsComplete   = $true
      GapSinceLastLogoff = $null
      IsGapSuspicious    = $false
    })
  }

  foreach ($l in $Logons) {
    if (-not $l.LogonId) { continue }
    $hasSession = $sessions | Where-Object { $_.LogonId -eq $l.LogonId -and $_.LogonTime -eq $l.Time }
    if ($hasSession) { continue }

    $groups = Get-AccountGroups -Account $l.Account
    $risk   = Get-RiskScore -LogonKind $l.LogonKind -IpAddress $l.IpAddress -Groups $groups -LogonTime $l.Time

    $sessions.Add([pscustomobject]@{
      Account      = $l.Account
      Groups       = $groups -join ", "
      LogonId      = $l.LogonId
      LogonTime    = $l.Time
      LogoffTime   = $null
      Duration     = $null
      LogonKind    = $l.LogonKind
      LogonType    = $l.LogonType
      IpAddress    = $l.IpAddress
      Process      = $l.Process
      LogoffEvent  = $null
      LogoffNotes  = $null
      RiskScore    = $risk.RiskScore
      RiskTags     = $risk.RiskTags
      IsHighRisk   = $risk.IsHighRisk
      WindowStart  = $StartTime
      IsComplete   = $false
      GapSinceLastLogoff = $null
      IsGapSuspicious    = $false
    })
  }

  Write-DebugLog -Message ("Join-Sessions: session count={0}" -f ($sessions.Count))

  $sessions | Sort-Object Account, LogonTime
}

function Measure-SessionGaps {
  param(
    [Parameter(Mandatory)]$Sessions
  )

  $byAccount = $Sessions | Group-Object Account
  $updated = New-Object 'System.Collections.Generic.List[object]'

  foreach ($grp in $byAccount) {
    $prevLogoff = $null
    foreach ($s in ($grp.Group | Sort-Object LogonTime)) {
      $gap = $null
      $suspicious = $false

      if ($prevLogoff -and $s.LogonTime) {
        $gap = $s.LogonTime - $prevLogoff
        # Keep threshold, but this is aggressive; tune as needed
        if ($gap.TotalMinutes -lt 1) {
          $suspicious = $true
        }
      }

      if ($s.LogoffTime) {
        $prevLogoff = $s.LogoffTime
      }

      $updated.Add([pscustomobject]@{
        Account      = $s.Account
        Groups       = $s.Groups
        LogonId      = $s.LogonId
        LogonTime    = $s.LogonTime
        LogoffTime   = $s.LogoffTime
        Duration     = $s.Duration
        LogonKind    = $s.LogonKind
        LogonType    = $s.LogonType
        IpAddress    = $s.IpAddress
        Process      = $s.Process
        LogoffEvent  = $s.LogoffEvent
        LogoffNotes  = $s.LogoffNotes
        RiskScore    = $s.RiskScore
        RiskTags     = $s.RiskTags
        IsHighRisk   = $s.IsHighRisk
        WindowStart  = $s.WindowStart
        IsComplete   = $s.IsComplete
        GapSinceLastLogoff = $gap
        IsGapSuspicious    = $suspicious
      })
    }
  }

  Write-DebugLog -Message ("Measure-SessionGaps: updated session count={0}" -f ($updated.Count))

  $updated | Sort-Object LogonTime
}

function New-SessionTimeline {
  param(
    [Parameter(Mandatory)]$TimelineEvents,
    [Parameter(Mandatory)]$Sessions
  )

  $sessionMarkers = foreach ($s in $Sessions) {
    [pscustomobject]@{
      Time      = $s.LogonTime
      Kind      = "SessionStart"
      EventId   = 0
      Account   = $s.Account
      LogonKind = $s.LogonKind
      LogonType = $s.LogonType
      LogonId   = $s.LogonId
      IpAddress = $s.IpAddress
      Process   = $s.Process
      Notes     = "Session start (Risk=$($s.RiskScore); $($s.RiskTags))"
    }

    if ($s.LogoffTime) {
      [pscustomobject]@{
        Time      = $s.LogoffTime
        Kind      = "SessionEnd"
        EventId   = $s.LogoffEvent
        Account   = $s.Account
        LogonKind = $s.LogonKind
        LogonType = $s.LogonType
        LogonId   = $s.LogonId
        IpAddress = $s.IpAddress
        Process   = $s.Process
        Notes     = "Session end"
      }
    }
  }

  $combined = @($TimelineEvents + $sessionMarkers) | Sort-Object Time
  Write-DebugLog -Message ("New-SessionTimeline: event+marker count={0}" -f ($combined.Count))
  $combined
}

# PS 5.1-safe HTML fragment helper (strip outer html/body)
function ConvertTo-HtmlFragment {
  param(
    [Parameter(Mandatory)]$InputObject,
    [string]$PreContent
  )

  $html = $InputObject | ConvertTo-Html -PreContent $PreContent
  $start = ($html | Select-String -Pattern '<body>').LineNumber
  $end   = ($html | Select-String -Pattern '</body>').LineNumber

  if (-not $start -or -not $end) {
    return $html
  }

  # Skip <html>, <head>, <body> lines; take inner table
  return $html[($start) .. ($end-2)]
}

# -----------------------------
# 1) Max timeline
# -----------------------------
$secOldest = Get-EventOldestTime -LogName "Security" -Ids @(4624,4634,4647)
$sysOldest = Get-EventOldestTime -LogName "System"   -Ids @(6005,6006,6008,41,1074,6009)

$secNewest = Get-EventNewestTime -LogName "Security" -Ids @(4624,4634,4647)
$sysNewest = Get-EventNewestTime -LogName "System"   -Ids @(6005,6006,6008,41,1074,6009)

$maxOldest = @($secOldest,$sysOldest) | Where-Object { $_ } | Sort-Object | Select-Object -First 1
$maxNewest = @($secNewest,$sysNewest) | Where-Object { $_ } | Sort-Object -Descending | Select-Object -First 1

Write-DebugLog -Message ("Max timeline: secOldest={0}, sysOldest={1}, secNewest={2}, sysNewest={3}" -f $secOldest, $sysOldest, $secNewest, $sysNewest)

Write-Host ""
Write-Host "=== Maximum Available Timeline (Security+System) ===" -ForegroundColor Cyan
Write-Host ("Oldest relevant event: {0}" -f ($(if ($maxOldest) { $maxOldest.ToString("yyyy-MM-dd HH:mm:ss") } else { "Unknown" })))
Write-Host ("Newest relevant event: {0}" -f ($(if ($maxNewest) { $maxNewest.ToString("yyyy-MM-dd HH:mm:ss") } else { "Unknown" })))
Write-Host ""
# -----------------------------
# 2) Window
# -----------------------------
$startTime = Get-StartTime -Window $Window -Hours $Hours
if ($Window -eq "Max") { $startTime = $null }

Write-Host "=== Evaluation Window ===" -ForegroundColor Cyan
if ($startTime) {
  Write-Host ("StartTime: {0}  (Now: {1})" -f $startTime.ToString("yyyy-MM-dd HH:mm:ss"), (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"))
} else {
  Write-Host "StartTime: (Max)  => querying as far back as event logs allow (may take longer)"
}
Write-Host ""

Write-DebugLog -Message ("Evaluation window startTime={0}" -f $startTime)

# -----------------------------
# 3) Collect events
# -----------------------------
$reboots = Get-RebootMarkers -StartTime $startTime
$logons  = Get-LogonEvents  -StartTime $startTime -IncludeComputerAccounts:$IncludeComputerAccounts -IncludeNoiseAccounts:$IncludeNoiseAccounts
$logoffs = Get-LogoffEvents -StartTime $startTime -IncludeComputerAccounts:$IncludeComputerAccounts -IncludeNoiseAccounts:$IncludeNoiseAccounts

Write-DebugLog -Message ("Collected: reboots={0}, logons={1}, logoffs={2}" -f ($reboots.Count), ($logons.Count), ($logoffs.Count))

$timeline = @($reboots + $logons + $logoffs) | Sort-Object Time

# -----------------------------
# 4) Reboot context
# -----------------------------
$lastBoot = Get-LastBootMarkerTime
Write-Host "=== Reboot Context ===" -ForegroundColor Cyan
if ($lastBoot) {
    Write-Host ("Last boot time (CIM/Event best-effort): {0}" -f $lastBoot.ToString("yyyy-MM-dd HH:mm:ss"))
} else {
    Write-Host "Last boot time (CIM/Event best-effort): Unknown"
}
Write-Host ""

Write-DebugLog -Message ("LastBoot={0}" -f $lastBoot)

$currentSessions = Get-CurrentLoggedOnUsers
$currentAfterBoot = if ($lastBoot) {
  $currentSessions | Where-Object { $_.StartTime -and $_.StartTime -ge $lastBoot }
} else {
  $currentSessions
}

$logonsAfterBoot = if ($lastBoot) {
  $logons | Where-Object { $_.Time -ge $lastBoot }
} else {
  $logons
}

$allUsersAfterBoot = $logonsAfterBoot |
  Group-Object Account |
  ForEach-Object {
    $first = ($_.Group | Sort-Object Time | Select-Object -First 1).Time
    $last  = ($_.Group | Sort-Object Time -Descending | Select-Object -First 1).Time
    $kinds = ($_.Group.LogonKind | Sort-Object -Unique) -join ", "
    [pscustomobject]@{
      Account     = $_.Name
      FirstLogon  = $first
      LastLogon   = $last
      LogonKinds  = $kinds
      LogonCount  = $_.Count
    }
  } | Sort-Object LastLogon -Descending

Write-DebugLog -Message ("AllUsersAfterBoot count={0}" -f (($allUsersAfterBoot | Measure-Object).Count))

# -----------------------------
# 5) Sessions + gaps + timeline
# -----------------------------
$sessionsRaw      = Join-Sessions -Logons $logons -Logoffs $logoffs -StartTime $startTime
$sessions         = Measure-SessionGaps -Sessions $sessionsRaw
$sessionTimeline  = New-SessionTimeline -TimelineEvents $timeline -Sessions $sessions

# -----------------------------
# 6) Console output
# -----------------------------
Write-Host "=== Timeline (Events + Session Markers) ===" -ForegroundColor Cyan
$sessionTimeline |
  Select-Object Time, Kind, EventId, Account, LogonKind, LogonType, LogonId, IpAddress, Process, Notes |
  Format-Table -AutoSize

Write-Host ""
Write-Host "=== Correlated Sessions (with Risk, Groups, Gaps) ===" -ForegroundColor Cyan
$sessions |
  Select-Object Account, Groups, LogonTime, LogoffTime, Duration, LogonKind, IpAddress, RiskScore, RiskTags, IsHighRisk, IsComplete, GapSinceLastLogoff, IsGapSuspicious |
  Sort-Object LogonTime |
  Format-Table -AutoSize

Write-Host ""
Write-Host "=== Summary: Currently Logged On Users (Live) ===" -ForegroundColor Cyan
$currentSessions |
  Select-Object Account, LogonType, StartTime, LogonId |
  Sort-Object Account |
  Format-Table -AutoSize

Write-Host ""
Write-Host "=== Summary: Currently Logged On Users After Reboot ===" -ForegroundColor Cyan
$currentAfterBoot |
  Select-Object Account, LogonType, StartTime, LogonId |
  Sort-Object Account |
  Format-Table -AutoSize

Write-Host ""
Write-Host "=== Summary: All Users Logged On After Reboot (from 4624 events) ===" -ForegroundColor Cyan
$allUsersAfterBoot |
  Select-Object Account, FirstLogon, LastLogon, LogonKinds, LogonCount |
  Format-Table -AutoSize

# -----------------------------
# 7) CSV / HTML (PS 5.1-safe)
# -----------------------------
if ($OutputCsv) {
  try {
    $sessions | Export-Csv -Path $OutputCsv -NoTypeInformation -Encoding UTF8
    Write-Host ("[+] Sessions CSV written to {0}" -f $OutputCsv) -ForegroundColor Green
    Write-DebugLog -Message ("CSV written to {0}" -f $OutputCsv)
  } catch {
    Write-Host ("[!] Failed to write CSV: {0}" -f $_.Exception.Message) -ForegroundColor Red
    Write-DebugLog -Message ("CSV write failed: {0}" -f $_.Exception.Message)
  }
}

if ($OutputHtml) {
  try {
    $style = @"
<style>
body { font-family: Segoe UI, Arial, sans-serif; font-size: 12px; }
table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
th, td { border: 1px solid #ccc; padding: 4px 6px; text-align: left; }
th { background-color: #f0f0f0; }
tr.highrisk { background-color: #ffcccc; }
tr.mediumrisk { background-color: #fff2cc; }
tr.lowrisk { background-color: #e6ffea; }
tr.suspiciousgap { border: 2px solid #ff9900; }
h1, h2 { font-family: Segoe UI, Arial, sans-serif; }
</style>
"@

    $timelineTable = ConvertTo-HtmlFragment -InputObject ($sessionTimeline |
      Select-Object Time, Kind, EventId, Account, LogonKind, LogonType, LogonId, IpAddress, Process, Notes) -PreContent "<h2>Timeline (Events + Sessions)</h2>"

    $sessionRows = foreach ($s in $sessions | Sort-Object LogonTime) {
      $class = "lowrisk"
      if ($s.RiskScore -ge 60) { $class = "highrisk" }
      elseif ($s.RiskScore -ge 30) { $class = "mediumrisk" }

      if ($s.IsGapSuspicious) {
        $class += " suspiciousgap"
      }

      "<tr class='$class'><td>$($s.Account)</td><td>$($s.Groups)</td><td>$($s.LogonTime)</td><td>$($s.LogoffTime)</td><td>$($s.Duration)</td><td>$($s.LogonKind)</td><td>$($s.IpAddress)</td><td>$($s.RiskScore)</td><td>$($s.RiskTags)</td><td>$($s.IsHighRisk)</td><td>$($s.IsComplete)</td><td>$($s.GapSinceLastLogoff)</td><td>$($s.IsGapSuspicious)</td></tr>"
    }

    $sessionsTable = @"
<h2>Correlated Sessions</h2>
<table>
  <thead>
    <tr>
      <th>Account</th><th>Groups</th><th>LogonTime</th><th>LogoffTime</th><th>Duration</th>
      <th>LogonKind</th><th>IpAddress</th><th>RiskScore</th><th>RiskTags</th>
      <th>IsHighRisk</th><th>IsComplete</th><th>GapSinceLastLogoff</th><th>IsGapSuspicious</th>
    </tr>
  </thead>
  <tbody>
    $($sessionRows -join "`n")
  </tbody>
</table>
"@

    $summaryTable = ConvertTo-HtmlFragment -InputObject ($allUsersAfterBoot |
      Select-Object Account, FirstLogon, LastLogon, LogonKinds, LogonCount) -PreContent "<h2>Users Logged On After Reboot</h2>"

    $body = @"
<h1>Local Logon Review</h1>
<p>Generated: $(Get-Date)</p>
$($timelineTable -join "`n")
$sessionsTable
$($summaryTable -join "`n")
"@

    $fullHtml = ConvertTo-Html -Body $body -Title "Local Logon Review" -Head $style
    $fullHtml | Out-File -FilePath $OutputHtml -Encoding UTF8

    Write-Host ("[+] HTML report written to {0}" -f $OutputHtml) -ForegroundColor Green
    Write-DebugLog -Message ("HTML written to {0}" -f $OutputHtml)
  } catch {
    Write-Host ("[!] Failed to write HTML: {0}" -f $_.Exception.Message) -ForegroundColor Red
    Write-DebugLog -Message ("HTML write failed: {0}" -f $_.Exception.Message)
  }
}

Write-DebugLog -Message "Script end."

$sessionTimeline
